package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/Hiroya3/learning-graphql/db"
	"github.com/Hiroya3/learning-graphql/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// PostPhoto is the resolver for the postPhoto field.
func (r *mutationResolver) PostPhoto(ctx context.Context, input model.PostPhotoInput) (*model.Photo, error) {
	now := time.Now()

	result, err := r.DbClient.Database(dbName).Collection(photoCollection).InsertOne(ctx, &db.Photo{
		Name:        input.Name,
		Description: input.Description,
		Category:    string(*input.Category),
		CreatedAt:   now,
	})
	if err != nil {
		log.Printf("fail to postPhoto,%v", err)
		return nil, err
	}

	return &model.Photo{
		ID:          result.InsertedID.(primitive.ObjectID).Hex(),
		Name:        input.Name,
		Description: input.Description,
		Category:    *input.Category,
		Created:     now.String(),
	}, nil
}

// TagPhoto is the resolver for the tagPhoto field.
func (r *mutationResolver) TagPhoto(ctx context.Context, githubLogin string, photoID string) (*model.Photo, error) {
	panic(fmt.Errorf("not implemented: TagPhoto - tagPhoto"))
}

// GithubAuth is the resolver for the githubAuth field.
func (r *mutationResolver) GithubAuth(ctx context.Context, code string) (*model.AuthPayload, error) {
	return r.AuthService.GetAuth(ctx, code)
}

// AddFakeUsers is the resolver for the addFakeUsers field.
func (r *mutationResolver) AddFakeUsers(ctx context.Context, count *int) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: AddFakeUsers - addFakeUsers"))
}

// FakeUserAuth is the resolver for the fakeUserAuth field.
func (r *mutationResolver) FakeUserAuth(ctx context.Context, githubLogin string) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: FakeUserAuth - fakeUserAuth"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Me - me"))
}

// TotalPhotos is the resolver for the totalPhotos field.
func (r *queryResolver) TotalPhotos(ctx context.Context) (int, error) {
	counts, err := r.DbClient.Database(dbName).Collection(photoCollection).CountDocuments(ctx, &bson.D{})
	if err != nil {
		log.Printf("fail to count totalPhotos,%v", err)
		return 0, err
	}
	return int(counts), nil
}

// AllPhotos is the resolver for the allPhotos field.
func (r *queryResolver) AllPhotos(ctx context.Context) ([]*model.Photo, error) {
	res, err := r.DbClient.Database(dbName).Collection(photoCollection).Find(ctx, &bson.D{})
	if err != nil {
		log.Printf("fail to find allPhotos,%v", err)
		return nil, err
	}

	result := make([]*model.Photo, 0)

	for res.Next(ctx) {
		var v db.Photo
		err = res.Decode(&v)
		if err != nil {
			log.Printf("fail to decode,%v", err)
			return nil, err
		}

		result = append(result, &model.Photo{
			ID:          v.Id,
			Name:        v.Name,
			URL:         v.URL,
			Description: v.Description,
			Category:    model.PhotoCategory(v.Category),
			PostedBy:    nil,             // 現時点はnil
			TaggedUsers: []*model.User{}, // 現時点はnil
			Created:     v.CreatedAt.String(),
		})
	}

	err = res.All(ctx, &result)
	if err != nil {
		log.Printf("fail to bind allPhotos,%v", err)
		return nil, err
	}

	return result, nil
}

// Photo is the resolver for the Photo field.
func (r *queryResolver) Photo(ctx context.Context, id string) (*model.Photo, error) {
	panic(fmt.Errorf("not implemented: Photo - Photo"))
}

// TotalUsers is the resolver for the totalUsers field.
func (r *queryResolver) TotalUsers(ctx context.Context) (int, error) {
	panic(fmt.Errorf("not implemented: TotalUsers - totalUsers"))
}

// AllUsers is the resolver for the allUsers field.
func (r *queryResolver) AllUsers(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: AllUsers - allUsers"))
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, login string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - User"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
